// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/deckhouse/dmt/pkg.Module -o module_mock.go -n ModuleMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/deckhouse/dmt/internal/storage"
	"github.com/gojuno/minimock/v3"
	"helm.sh/helm/v3/pkg/chart"
)

// ModuleMock implements mm_pkg.Module
type ModuleMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetChart          func() (cp1 *chart.Chart)
	funcGetChartOrigin    string
	inspectFuncGetChart   func()
	afterGetChartCounter  uint64
	beforeGetChartCounter uint64
	GetChartMock          mModuleMockGetChart

	funcGetName          func() (s1 string)
	funcGetNameOrigin    string
	inspectFuncGetName   func()
	afterGetNameCounter  uint64
	beforeGetNameCounter uint64
	GetNameMock          mModuleMockGetName

	funcGetNamespace          func() (s1 string)
	funcGetNamespaceOrigin    string
	inspectFuncGetNamespace   func()
	afterGetNamespaceCounter  uint64
	beforeGetNamespaceCounter uint64
	GetNamespaceMock          mModuleMockGetNamespace

	funcGetObjectStore          func() (up1 *storage.UnstructuredObjectStore)
	funcGetObjectStoreOrigin    string
	inspectFuncGetObjectStore   func()
	afterGetObjectStoreCounter  uint64
	beforeGetObjectStoreCounter uint64
	GetObjectStoreMock          mModuleMockGetObjectStore

	funcGetPath          func() (s1 string)
	funcGetPathOrigin    string
	inspectFuncGetPath   func()
	afterGetPathCounter  uint64
	beforeGetPathCounter uint64
	GetPathMock          mModuleMockGetPath

	funcGetStorage          func() (m1 map[storage.ResourceIndex]storage.StoreObject)
	funcGetStorageOrigin    string
	inspectFuncGetStorage   func()
	afterGetStorageCounter  uint64
	beforeGetStorageCounter uint64
	GetStorageMock          mModuleMockGetStorage

	funcGetWerfFile          func() (s1 string)
	funcGetWerfFileOrigin    string
	inspectFuncGetWerfFile   func()
	afterGetWerfFileCounter  uint64
	beforeGetWerfFileCounter uint64
	GetWerfFileMock          mModuleMockGetWerfFile
}

// NewModuleMock returns a mock for mm_pkg.Module
func NewModuleMock(t minimock.Tester) *ModuleMock {
	m := &ModuleMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetChartMock = mModuleMockGetChart{mock: m}

	m.GetNameMock = mModuleMockGetName{mock: m}

	m.GetNamespaceMock = mModuleMockGetNamespace{mock: m}

	m.GetObjectStoreMock = mModuleMockGetObjectStore{mock: m}

	m.GetPathMock = mModuleMockGetPath{mock: m}

	m.GetStorageMock = mModuleMockGetStorage{mock: m}

	m.GetWerfFileMock = mModuleMockGetWerfFile{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mModuleMockGetChart struct {
	optional           bool
	mock               *ModuleMock
	defaultExpectation *ModuleMockGetChartExpectation
	expectations       []*ModuleMockGetChartExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModuleMockGetChartExpectation specifies expectation struct of the Module.GetChart
type ModuleMockGetChartExpectation struct {
	mock *ModuleMock

	results      *ModuleMockGetChartResults
	returnOrigin string
	Counter      uint64
}

// ModuleMockGetChartResults contains results of the Module.GetChart
type ModuleMockGetChartResults struct {
	cp1 *chart.Chart
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetChart *mModuleMockGetChart) Optional() *mModuleMockGetChart {
	mmGetChart.optional = true
	return mmGetChart
}

// Expect sets up expected params for Module.GetChart
func (mmGetChart *mModuleMockGetChart) Expect() *mModuleMockGetChart {
	if mmGetChart.mock.funcGetChart != nil {
		mmGetChart.mock.t.Fatalf("ModuleMock.GetChart mock is already set by Set")
	}

	if mmGetChart.defaultExpectation == nil {
		mmGetChart.defaultExpectation = &ModuleMockGetChartExpectation{}
	}

	return mmGetChart
}

// Inspect accepts an inspector function that has same arguments as the Module.GetChart
func (mmGetChart *mModuleMockGetChart) Inspect(f func()) *mModuleMockGetChart {
	if mmGetChart.mock.inspectFuncGetChart != nil {
		mmGetChart.mock.t.Fatalf("Inspect function is already set for ModuleMock.GetChart")
	}

	mmGetChart.mock.inspectFuncGetChart = f

	return mmGetChart
}

// Return sets up results that will be returned by Module.GetChart
func (mmGetChart *mModuleMockGetChart) Return(cp1 *chart.Chart) *ModuleMock {
	if mmGetChart.mock.funcGetChart != nil {
		mmGetChart.mock.t.Fatalf("ModuleMock.GetChart mock is already set by Set")
	}

	if mmGetChart.defaultExpectation == nil {
		mmGetChart.defaultExpectation = &ModuleMockGetChartExpectation{mock: mmGetChart.mock}
	}
	mmGetChart.defaultExpectation.results = &ModuleMockGetChartResults{cp1}
	mmGetChart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetChart.mock
}

// Set uses given function f to mock the Module.GetChart method
func (mmGetChart *mModuleMockGetChart) Set(f func() (cp1 *chart.Chart)) *ModuleMock {
	if mmGetChart.defaultExpectation != nil {
		mmGetChart.mock.t.Fatalf("Default expectation is already set for the Module.GetChart method")
	}

	if len(mmGetChart.expectations) > 0 {
		mmGetChart.mock.t.Fatalf("Some expectations are already set for the Module.GetChart method")
	}

	mmGetChart.mock.funcGetChart = f
	mmGetChart.mock.funcGetChartOrigin = minimock.CallerInfo(1)
	return mmGetChart.mock
}

// Times sets number of times Module.GetChart should be invoked
func (mmGetChart *mModuleMockGetChart) Times(n uint64) *mModuleMockGetChart {
	if n == 0 {
		mmGetChart.mock.t.Fatalf("Times of ModuleMock.GetChart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetChart.expectedInvocations, n)
	mmGetChart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetChart
}

func (mmGetChart *mModuleMockGetChart) invocationsDone() bool {
	if len(mmGetChart.expectations) == 0 && mmGetChart.defaultExpectation == nil && mmGetChart.mock.funcGetChart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetChart.mock.afterGetChartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetChart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetChart implements mm_pkg.Module
func (mmGetChart *ModuleMock) GetChart() (cp1 *chart.Chart) {
	mm_atomic.AddUint64(&mmGetChart.beforeGetChartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetChart.afterGetChartCounter, 1)

	mmGetChart.t.Helper()

	if mmGetChart.inspectFuncGetChart != nil {
		mmGetChart.inspectFuncGetChart()
	}

	if mmGetChart.GetChartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetChart.GetChartMock.defaultExpectation.Counter, 1)

		mm_results := mmGetChart.GetChartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetChart.t.Fatal("No results are set for the ModuleMock.GetChart")
		}
		return (*mm_results).cp1
	}
	if mmGetChart.funcGetChart != nil {
		return mmGetChart.funcGetChart()
	}
	mmGetChart.t.Fatalf("Unexpected call to ModuleMock.GetChart.")
	return
}

// GetChartAfterCounter returns a count of finished ModuleMock.GetChart invocations
func (mmGetChart *ModuleMock) GetChartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChart.afterGetChartCounter)
}

// GetChartBeforeCounter returns a count of ModuleMock.GetChart invocations
func (mmGetChart *ModuleMock) GetChartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetChart.beforeGetChartCounter)
}

// MinimockGetChartDone returns true if the count of the GetChart invocations corresponds
// the number of defined expectations
func (m *ModuleMock) MinimockGetChartDone() bool {
	if m.GetChartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetChartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetChartMock.invocationsDone()
}

// MinimockGetChartInspect logs each unmet expectation
func (m *ModuleMock) MinimockGetChartInspect() {
	for _, e := range m.GetChartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ModuleMock.GetChart")
		}
	}

	afterGetChartCounter := mm_atomic.LoadUint64(&m.afterGetChartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetChartMock.defaultExpectation != nil && afterGetChartCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetChart at\n%s", m.GetChartMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetChart != nil && afterGetChartCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetChart at\n%s", m.funcGetChartOrigin)
	}

	if !m.GetChartMock.invocationsDone() && afterGetChartCounter > 0 {
		m.t.Errorf("Expected %d calls to ModuleMock.GetChart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetChartMock.expectedInvocations), m.GetChartMock.expectedInvocationsOrigin, afterGetChartCounter)
	}
}

type mModuleMockGetName struct {
	optional           bool
	mock               *ModuleMock
	defaultExpectation *ModuleMockGetNameExpectation
	expectations       []*ModuleMockGetNameExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModuleMockGetNameExpectation specifies expectation struct of the Module.GetName
type ModuleMockGetNameExpectation struct {
	mock *ModuleMock

	results      *ModuleMockGetNameResults
	returnOrigin string
	Counter      uint64
}

// ModuleMockGetNameResults contains results of the Module.GetName
type ModuleMockGetNameResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetName *mModuleMockGetName) Optional() *mModuleMockGetName {
	mmGetName.optional = true
	return mmGetName
}

// Expect sets up expected params for Module.GetName
func (mmGetName *mModuleMockGetName) Expect() *mModuleMockGetName {
	if mmGetName.mock.funcGetName != nil {
		mmGetName.mock.t.Fatalf("ModuleMock.GetName mock is already set by Set")
	}

	if mmGetName.defaultExpectation == nil {
		mmGetName.defaultExpectation = &ModuleMockGetNameExpectation{}
	}

	return mmGetName
}

// Inspect accepts an inspector function that has same arguments as the Module.GetName
func (mmGetName *mModuleMockGetName) Inspect(f func()) *mModuleMockGetName {
	if mmGetName.mock.inspectFuncGetName != nil {
		mmGetName.mock.t.Fatalf("Inspect function is already set for ModuleMock.GetName")
	}

	mmGetName.mock.inspectFuncGetName = f

	return mmGetName
}

// Return sets up results that will be returned by Module.GetName
func (mmGetName *mModuleMockGetName) Return(s1 string) *ModuleMock {
	if mmGetName.mock.funcGetName != nil {
		mmGetName.mock.t.Fatalf("ModuleMock.GetName mock is already set by Set")
	}

	if mmGetName.defaultExpectation == nil {
		mmGetName.defaultExpectation = &ModuleMockGetNameExpectation{mock: mmGetName.mock}
	}
	mmGetName.defaultExpectation.results = &ModuleMockGetNameResults{s1}
	mmGetName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetName.mock
}

// Set uses given function f to mock the Module.GetName method
func (mmGetName *mModuleMockGetName) Set(f func() (s1 string)) *ModuleMock {
	if mmGetName.defaultExpectation != nil {
		mmGetName.mock.t.Fatalf("Default expectation is already set for the Module.GetName method")
	}

	if len(mmGetName.expectations) > 0 {
		mmGetName.mock.t.Fatalf("Some expectations are already set for the Module.GetName method")
	}

	mmGetName.mock.funcGetName = f
	mmGetName.mock.funcGetNameOrigin = minimock.CallerInfo(1)
	return mmGetName.mock
}

// Times sets number of times Module.GetName should be invoked
func (mmGetName *mModuleMockGetName) Times(n uint64) *mModuleMockGetName {
	if n == 0 {
		mmGetName.mock.t.Fatalf("Times of ModuleMock.GetName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetName.expectedInvocations, n)
	mmGetName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetName
}

func (mmGetName *mModuleMockGetName) invocationsDone() bool {
	if len(mmGetName.expectations) == 0 && mmGetName.defaultExpectation == nil && mmGetName.mock.funcGetName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetName.mock.afterGetNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetName implements mm_pkg.Module
func (mmGetName *ModuleMock) GetName() (s1 string) {
	mm_atomic.AddUint64(&mmGetName.beforeGetNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetName.afterGetNameCounter, 1)

	mmGetName.t.Helper()

	if mmGetName.inspectFuncGetName != nil {
		mmGetName.inspectFuncGetName()
	}

	if mmGetName.GetNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetName.GetNameMock.defaultExpectation.Counter, 1)

		mm_results := mmGetName.GetNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetName.t.Fatal("No results are set for the ModuleMock.GetName")
		}
		return (*mm_results).s1
	}
	if mmGetName.funcGetName != nil {
		return mmGetName.funcGetName()
	}
	mmGetName.t.Fatalf("Unexpected call to ModuleMock.GetName.")
	return
}

// GetNameAfterCounter returns a count of finished ModuleMock.GetName invocations
func (mmGetName *ModuleMock) GetNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetName.afterGetNameCounter)
}

// GetNameBeforeCounter returns a count of ModuleMock.GetName invocations
func (mmGetName *ModuleMock) GetNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetName.beforeGetNameCounter)
}

// MinimockGetNameDone returns true if the count of the GetName invocations corresponds
// the number of defined expectations
func (m *ModuleMock) MinimockGetNameDone() bool {
	if m.GetNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNameMock.invocationsDone()
}

// MinimockGetNameInspect logs each unmet expectation
func (m *ModuleMock) MinimockGetNameInspect() {
	for _, e := range m.GetNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ModuleMock.GetName")
		}
	}

	afterGetNameCounter := mm_atomic.LoadUint64(&m.afterGetNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNameMock.defaultExpectation != nil && afterGetNameCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetName at\n%s", m.GetNameMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetName != nil && afterGetNameCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetName at\n%s", m.funcGetNameOrigin)
	}

	if !m.GetNameMock.invocationsDone() && afterGetNameCounter > 0 {
		m.t.Errorf("Expected %d calls to ModuleMock.GetName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNameMock.expectedInvocations), m.GetNameMock.expectedInvocationsOrigin, afterGetNameCounter)
	}
}

type mModuleMockGetNamespace struct {
	optional           bool
	mock               *ModuleMock
	defaultExpectation *ModuleMockGetNamespaceExpectation
	expectations       []*ModuleMockGetNamespaceExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModuleMockGetNamespaceExpectation specifies expectation struct of the Module.GetNamespace
type ModuleMockGetNamespaceExpectation struct {
	mock *ModuleMock

	results      *ModuleMockGetNamespaceResults
	returnOrigin string
	Counter      uint64
}

// ModuleMockGetNamespaceResults contains results of the Module.GetNamespace
type ModuleMockGetNamespaceResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespace *mModuleMockGetNamespace) Optional() *mModuleMockGetNamespace {
	mmGetNamespace.optional = true
	return mmGetNamespace
}

// Expect sets up expected params for Module.GetNamespace
func (mmGetNamespace *mModuleMockGetNamespace) Expect() *mModuleMockGetNamespace {
	if mmGetNamespace.mock.funcGetNamespace != nil {
		mmGetNamespace.mock.t.Fatalf("ModuleMock.GetNamespace mock is already set by Set")
	}

	if mmGetNamespace.defaultExpectation == nil {
		mmGetNamespace.defaultExpectation = &ModuleMockGetNamespaceExpectation{}
	}

	return mmGetNamespace
}

// Inspect accepts an inspector function that has same arguments as the Module.GetNamespace
func (mmGetNamespace *mModuleMockGetNamespace) Inspect(f func()) *mModuleMockGetNamespace {
	if mmGetNamespace.mock.inspectFuncGetNamespace != nil {
		mmGetNamespace.mock.t.Fatalf("Inspect function is already set for ModuleMock.GetNamespace")
	}

	mmGetNamespace.mock.inspectFuncGetNamespace = f

	return mmGetNamespace
}

// Return sets up results that will be returned by Module.GetNamespace
func (mmGetNamespace *mModuleMockGetNamespace) Return(s1 string) *ModuleMock {
	if mmGetNamespace.mock.funcGetNamespace != nil {
		mmGetNamespace.mock.t.Fatalf("ModuleMock.GetNamespace mock is already set by Set")
	}

	if mmGetNamespace.defaultExpectation == nil {
		mmGetNamespace.defaultExpectation = &ModuleMockGetNamespaceExpectation{mock: mmGetNamespace.mock}
	}
	mmGetNamespace.defaultExpectation.results = &ModuleMockGetNamespaceResults{s1}
	mmGetNamespace.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespace.mock
}

// Set uses given function f to mock the Module.GetNamespace method
func (mmGetNamespace *mModuleMockGetNamespace) Set(f func() (s1 string)) *ModuleMock {
	if mmGetNamespace.defaultExpectation != nil {
		mmGetNamespace.mock.t.Fatalf("Default expectation is already set for the Module.GetNamespace method")
	}

	if len(mmGetNamespace.expectations) > 0 {
		mmGetNamespace.mock.t.Fatalf("Some expectations are already set for the Module.GetNamespace method")
	}

	mmGetNamespace.mock.funcGetNamespace = f
	mmGetNamespace.mock.funcGetNamespaceOrigin = minimock.CallerInfo(1)
	return mmGetNamespace.mock
}

// Times sets number of times Module.GetNamespace should be invoked
func (mmGetNamespace *mModuleMockGetNamespace) Times(n uint64) *mModuleMockGetNamespace {
	if n == 0 {
		mmGetNamespace.mock.t.Fatalf("Times of ModuleMock.GetNamespace mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespace.expectedInvocations, n)
	mmGetNamespace.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespace
}

func (mmGetNamespace *mModuleMockGetNamespace) invocationsDone() bool {
	if len(mmGetNamespace.expectations) == 0 && mmGetNamespace.defaultExpectation == nil && mmGetNamespace.mock.funcGetNamespace == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespace.mock.afterGetNamespaceCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespace.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespace implements mm_pkg.Module
func (mmGetNamespace *ModuleMock) GetNamespace() (s1 string) {
	mm_atomic.AddUint64(&mmGetNamespace.beforeGetNamespaceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespace.afterGetNamespaceCounter, 1)

	mmGetNamespace.t.Helper()

	if mmGetNamespace.inspectFuncGetNamespace != nil {
		mmGetNamespace.inspectFuncGetNamespace()
	}

	if mmGetNamespace.GetNamespaceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespace.GetNamespaceMock.defaultExpectation.Counter, 1)

		mm_results := mmGetNamespace.GetNamespaceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespace.t.Fatal("No results are set for the ModuleMock.GetNamespace")
		}
		return (*mm_results).s1
	}
	if mmGetNamespace.funcGetNamespace != nil {
		return mmGetNamespace.funcGetNamespace()
	}
	mmGetNamespace.t.Fatalf("Unexpected call to ModuleMock.GetNamespace.")
	return
}

// GetNamespaceAfterCounter returns a count of finished ModuleMock.GetNamespace invocations
func (mmGetNamespace *ModuleMock) GetNamespaceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespace.afterGetNamespaceCounter)
}

// GetNamespaceBeforeCounter returns a count of ModuleMock.GetNamespace invocations
func (mmGetNamespace *ModuleMock) GetNamespaceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespace.beforeGetNamespaceCounter)
}

// MinimockGetNamespaceDone returns true if the count of the GetNamespace invocations corresponds
// the number of defined expectations
func (m *ModuleMock) MinimockGetNamespaceDone() bool {
	if m.GetNamespaceMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceMock.invocationsDone()
}

// MinimockGetNamespaceInspect logs each unmet expectation
func (m *ModuleMock) MinimockGetNamespaceInspect() {
	for _, e := range m.GetNamespaceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ModuleMock.GetNamespace")
		}
	}

	afterGetNamespaceCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceMock.defaultExpectation != nil && afterGetNamespaceCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetNamespace at\n%s", m.GetNamespaceMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespace != nil && afterGetNamespaceCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetNamespace at\n%s", m.funcGetNamespaceOrigin)
	}

	if !m.GetNamespaceMock.invocationsDone() && afterGetNamespaceCounter > 0 {
		m.t.Errorf("Expected %d calls to ModuleMock.GetNamespace at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceMock.expectedInvocations), m.GetNamespaceMock.expectedInvocationsOrigin, afterGetNamespaceCounter)
	}
}

type mModuleMockGetObjectStore struct {
	optional           bool
	mock               *ModuleMock
	defaultExpectation *ModuleMockGetObjectStoreExpectation
	expectations       []*ModuleMockGetObjectStoreExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModuleMockGetObjectStoreExpectation specifies expectation struct of the Module.GetObjectStore
type ModuleMockGetObjectStoreExpectation struct {
	mock *ModuleMock

	results      *ModuleMockGetObjectStoreResults
	returnOrigin string
	Counter      uint64
}

// ModuleMockGetObjectStoreResults contains results of the Module.GetObjectStore
type ModuleMockGetObjectStoreResults struct {
	up1 *storage.UnstructuredObjectStore
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetObjectStore *mModuleMockGetObjectStore) Optional() *mModuleMockGetObjectStore {
	mmGetObjectStore.optional = true
	return mmGetObjectStore
}

// Expect sets up expected params for Module.GetObjectStore
func (mmGetObjectStore *mModuleMockGetObjectStore) Expect() *mModuleMockGetObjectStore {
	if mmGetObjectStore.mock.funcGetObjectStore != nil {
		mmGetObjectStore.mock.t.Fatalf("ModuleMock.GetObjectStore mock is already set by Set")
	}

	if mmGetObjectStore.defaultExpectation == nil {
		mmGetObjectStore.defaultExpectation = &ModuleMockGetObjectStoreExpectation{}
	}

	return mmGetObjectStore
}

// Inspect accepts an inspector function that has same arguments as the Module.GetObjectStore
func (mmGetObjectStore *mModuleMockGetObjectStore) Inspect(f func()) *mModuleMockGetObjectStore {
	if mmGetObjectStore.mock.inspectFuncGetObjectStore != nil {
		mmGetObjectStore.mock.t.Fatalf("Inspect function is already set for ModuleMock.GetObjectStore")
	}

	mmGetObjectStore.mock.inspectFuncGetObjectStore = f

	return mmGetObjectStore
}

// Return sets up results that will be returned by Module.GetObjectStore
func (mmGetObjectStore *mModuleMockGetObjectStore) Return(up1 *storage.UnstructuredObjectStore) *ModuleMock {
	if mmGetObjectStore.mock.funcGetObjectStore != nil {
		mmGetObjectStore.mock.t.Fatalf("ModuleMock.GetObjectStore mock is already set by Set")
	}

	if mmGetObjectStore.defaultExpectation == nil {
		mmGetObjectStore.defaultExpectation = &ModuleMockGetObjectStoreExpectation{mock: mmGetObjectStore.mock}
	}
	mmGetObjectStore.defaultExpectation.results = &ModuleMockGetObjectStoreResults{up1}
	mmGetObjectStore.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetObjectStore.mock
}

// Set uses given function f to mock the Module.GetObjectStore method
func (mmGetObjectStore *mModuleMockGetObjectStore) Set(f func() (up1 *storage.UnstructuredObjectStore)) *ModuleMock {
	if mmGetObjectStore.defaultExpectation != nil {
		mmGetObjectStore.mock.t.Fatalf("Default expectation is already set for the Module.GetObjectStore method")
	}

	if len(mmGetObjectStore.expectations) > 0 {
		mmGetObjectStore.mock.t.Fatalf("Some expectations are already set for the Module.GetObjectStore method")
	}

	mmGetObjectStore.mock.funcGetObjectStore = f
	mmGetObjectStore.mock.funcGetObjectStoreOrigin = minimock.CallerInfo(1)
	return mmGetObjectStore.mock
}

// Times sets number of times Module.GetObjectStore should be invoked
func (mmGetObjectStore *mModuleMockGetObjectStore) Times(n uint64) *mModuleMockGetObjectStore {
	if n == 0 {
		mmGetObjectStore.mock.t.Fatalf("Times of ModuleMock.GetObjectStore mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetObjectStore.expectedInvocations, n)
	mmGetObjectStore.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetObjectStore
}

func (mmGetObjectStore *mModuleMockGetObjectStore) invocationsDone() bool {
	if len(mmGetObjectStore.expectations) == 0 && mmGetObjectStore.defaultExpectation == nil && mmGetObjectStore.mock.funcGetObjectStore == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetObjectStore.mock.afterGetObjectStoreCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetObjectStore.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetObjectStore implements mm_pkg.Module
func (mmGetObjectStore *ModuleMock) GetObjectStore() (up1 *storage.UnstructuredObjectStore) {
	mm_atomic.AddUint64(&mmGetObjectStore.beforeGetObjectStoreCounter, 1)
	defer mm_atomic.AddUint64(&mmGetObjectStore.afterGetObjectStoreCounter, 1)

	mmGetObjectStore.t.Helper()

	if mmGetObjectStore.inspectFuncGetObjectStore != nil {
		mmGetObjectStore.inspectFuncGetObjectStore()
	}

	if mmGetObjectStore.GetObjectStoreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetObjectStore.GetObjectStoreMock.defaultExpectation.Counter, 1)

		mm_results := mmGetObjectStore.GetObjectStoreMock.defaultExpectation.results
		if mm_results == nil {
			mmGetObjectStore.t.Fatal("No results are set for the ModuleMock.GetObjectStore")
		}
		return (*mm_results).up1
	}
	if mmGetObjectStore.funcGetObjectStore != nil {
		return mmGetObjectStore.funcGetObjectStore()
	}
	mmGetObjectStore.t.Fatalf("Unexpected call to ModuleMock.GetObjectStore.")
	return
}

// GetObjectStoreAfterCounter returns a count of finished ModuleMock.GetObjectStore invocations
func (mmGetObjectStore *ModuleMock) GetObjectStoreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectStore.afterGetObjectStoreCounter)
}

// GetObjectStoreBeforeCounter returns a count of ModuleMock.GetObjectStore invocations
func (mmGetObjectStore *ModuleMock) GetObjectStoreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetObjectStore.beforeGetObjectStoreCounter)
}

// MinimockGetObjectStoreDone returns true if the count of the GetObjectStore invocations corresponds
// the number of defined expectations
func (m *ModuleMock) MinimockGetObjectStoreDone() bool {
	if m.GetObjectStoreMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetObjectStoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetObjectStoreMock.invocationsDone()
}

// MinimockGetObjectStoreInspect logs each unmet expectation
func (m *ModuleMock) MinimockGetObjectStoreInspect() {
	for _, e := range m.GetObjectStoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ModuleMock.GetObjectStore")
		}
	}

	afterGetObjectStoreCounter := mm_atomic.LoadUint64(&m.afterGetObjectStoreCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetObjectStoreMock.defaultExpectation != nil && afterGetObjectStoreCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetObjectStore at\n%s", m.GetObjectStoreMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetObjectStore != nil && afterGetObjectStoreCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetObjectStore at\n%s", m.funcGetObjectStoreOrigin)
	}

	if !m.GetObjectStoreMock.invocationsDone() && afterGetObjectStoreCounter > 0 {
		m.t.Errorf("Expected %d calls to ModuleMock.GetObjectStore at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetObjectStoreMock.expectedInvocations), m.GetObjectStoreMock.expectedInvocationsOrigin, afterGetObjectStoreCounter)
	}
}

type mModuleMockGetPath struct {
	optional           bool
	mock               *ModuleMock
	defaultExpectation *ModuleMockGetPathExpectation
	expectations       []*ModuleMockGetPathExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModuleMockGetPathExpectation specifies expectation struct of the Module.GetPath
type ModuleMockGetPathExpectation struct {
	mock *ModuleMock

	results      *ModuleMockGetPathResults
	returnOrigin string
	Counter      uint64
}

// ModuleMockGetPathResults contains results of the Module.GetPath
type ModuleMockGetPathResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPath *mModuleMockGetPath) Optional() *mModuleMockGetPath {
	mmGetPath.optional = true
	return mmGetPath
}

// Expect sets up expected params for Module.GetPath
func (mmGetPath *mModuleMockGetPath) Expect() *mModuleMockGetPath {
	if mmGetPath.mock.funcGetPath != nil {
		mmGetPath.mock.t.Fatalf("ModuleMock.GetPath mock is already set by Set")
	}

	if mmGetPath.defaultExpectation == nil {
		mmGetPath.defaultExpectation = &ModuleMockGetPathExpectation{}
	}

	return mmGetPath
}

// Inspect accepts an inspector function that has same arguments as the Module.GetPath
func (mmGetPath *mModuleMockGetPath) Inspect(f func()) *mModuleMockGetPath {
	if mmGetPath.mock.inspectFuncGetPath != nil {
		mmGetPath.mock.t.Fatalf("Inspect function is already set for ModuleMock.GetPath")
	}

	mmGetPath.mock.inspectFuncGetPath = f

	return mmGetPath
}

// Return sets up results that will be returned by Module.GetPath
func (mmGetPath *mModuleMockGetPath) Return(s1 string) *ModuleMock {
	if mmGetPath.mock.funcGetPath != nil {
		mmGetPath.mock.t.Fatalf("ModuleMock.GetPath mock is already set by Set")
	}

	if mmGetPath.defaultExpectation == nil {
		mmGetPath.defaultExpectation = &ModuleMockGetPathExpectation{mock: mmGetPath.mock}
	}
	mmGetPath.defaultExpectation.results = &ModuleMockGetPathResults{s1}
	mmGetPath.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPath.mock
}

// Set uses given function f to mock the Module.GetPath method
func (mmGetPath *mModuleMockGetPath) Set(f func() (s1 string)) *ModuleMock {
	if mmGetPath.defaultExpectation != nil {
		mmGetPath.mock.t.Fatalf("Default expectation is already set for the Module.GetPath method")
	}

	if len(mmGetPath.expectations) > 0 {
		mmGetPath.mock.t.Fatalf("Some expectations are already set for the Module.GetPath method")
	}

	mmGetPath.mock.funcGetPath = f
	mmGetPath.mock.funcGetPathOrigin = minimock.CallerInfo(1)
	return mmGetPath.mock
}

// Times sets number of times Module.GetPath should be invoked
func (mmGetPath *mModuleMockGetPath) Times(n uint64) *mModuleMockGetPath {
	if n == 0 {
		mmGetPath.mock.t.Fatalf("Times of ModuleMock.GetPath mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPath.expectedInvocations, n)
	mmGetPath.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPath
}

func (mmGetPath *mModuleMockGetPath) invocationsDone() bool {
	if len(mmGetPath.expectations) == 0 && mmGetPath.defaultExpectation == nil && mmGetPath.mock.funcGetPath == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPath.mock.afterGetPathCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPath.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPath implements mm_pkg.Module
func (mmGetPath *ModuleMock) GetPath() (s1 string) {
	mm_atomic.AddUint64(&mmGetPath.beforeGetPathCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPath.afterGetPathCounter, 1)

	mmGetPath.t.Helper()

	if mmGetPath.inspectFuncGetPath != nil {
		mmGetPath.inspectFuncGetPath()
	}

	if mmGetPath.GetPathMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPath.GetPathMock.defaultExpectation.Counter, 1)

		mm_results := mmGetPath.GetPathMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPath.t.Fatal("No results are set for the ModuleMock.GetPath")
		}
		return (*mm_results).s1
	}
	if mmGetPath.funcGetPath != nil {
		return mmGetPath.funcGetPath()
	}
	mmGetPath.t.Fatalf("Unexpected call to ModuleMock.GetPath.")
	return
}

// GetPathAfterCounter returns a count of finished ModuleMock.GetPath invocations
func (mmGetPath *ModuleMock) GetPathAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPath.afterGetPathCounter)
}

// GetPathBeforeCounter returns a count of ModuleMock.GetPath invocations
func (mmGetPath *ModuleMock) GetPathBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPath.beforeGetPathCounter)
}

// MinimockGetPathDone returns true if the count of the GetPath invocations corresponds
// the number of defined expectations
func (m *ModuleMock) MinimockGetPathDone() bool {
	if m.GetPathMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPathMock.invocationsDone()
}

// MinimockGetPathInspect logs each unmet expectation
func (m *ModuleMock) MinimockGetPathInspect() {
	for _, e := range m.GetPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ModuleMock.GetPath")
		}
	}

	afterGetPathCounter := mm_atomic.LoadUint64(&m.afterGetPathCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPathMock.defaultExpectation != nil && afterGetPathCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetPath at\n%s", m.GetPathMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPath != nil && afterGetPathCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetPath at\n%s", m.funcGetPathOrigin)
	}

	if !m.GetPathMock.invocationsDone() && afterGetPathCounter > 0 {
		m.t.Errorf("Expected %d calls to ModuleMock.GetPath at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPathMock.expectedInvocations), m.GetPathMock.expectedInvocationsOrigin, afterGetPathCounter)
	}
}

type mModuleMockGetStorage struct {
	optional           bool
	mock               *ModuleMock
	defaultExpectation *ModuleMockGetStorageExpectation
	expectations       []*ModuleMockGetStorageExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModuleMockGetStorageExpectation specifies expectation struct of the Module.GetStorage
type ModuleMockGetStorageExpectation struct {
	mock *ModuleMock

	results      *ModuleMockGetStorageResults
	returnOrigin string
	Counter      uint64
}

// ModuleMockGetStorageResults contains results of the Module.GetStorage
type ModuleMockGetStorageResults struct {
	m1 map[storage.ResourceIndex]storage.StoreObject
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStorage *mModuleMockGetStorage) Optional() *mModuleMockGetStorage {
	mmGetStorage.optional = true
	return mmGetStorage
}

// Expect sets up expected params for Module.GetStorage
func (mmGetStorage *mModuleMockGetStorage) Expect() *mModuleMockGetStorage {
	if mmGetStorage.mock.funcGetStorage != nil {
		mmGetStorage.mock.t.Fatalf("ModuleMock.GetStorage mock is already set by Set")
	}

	if mmGetStorage.defaultExpectation == nil {
		mmGetStorage.defaultExpectation = &ModuleMockGetStorageExpectation{}
	}

	return mmGetStorage
}

// Inspect accepts an inspector function that has same arguments as the Module.GetStorage
func (mmGetStorage *mModuleMockGetStorage) Inspect(f func()) *mModuleMockGetStorage {
	if mmGetStorage.mock.inspectFuncGetStorage != nil {
		mmGetStorage.mock.t.Fatalf("Inspect function is already set for ModuleMock.GetStorage")
	}

	mmGetStorage.mock.inspectFuncGetStorage = f

	return mmGetStorage
}

// Return sets up results that will be returned by Module.GetStorage
func (mmGetStorage *mModuleMockGetStorage) Return(m1 map[storage.ResourceIndex]storage.StoreObject) *ModuleMock {
	if mmGetStorage.mock.funcGetStorage != nil {
		mmGetStorage.mock.t.Fatalf("ModuleMock.GetStorage mock is already set by Set")
	}

	if mmGetStorage.defaultExpectation == nil {
		mmGetStorage.defaultExpectation = &ModuleMockGetStorageExpectation{mock: mmGetStorage.mock}
	}
	mmGetStorage.defaultExpectation.results = &ModuleMockGetStorageResults{m1}
	mmGetStorage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStorage.mock
}

// Set uses given function f to mock the Module.GetStorage method
func (mmGetStorage *mModuleMockGetStorage) Set(f func() (m1 map[storage.ResourceIndex]storage.StoreObject)) *ModuleMock {
	if mmGetStorage.defaultExpectation != nil {
		mmGetStorage.mock.t.Fatalf("Default expectation is already set for the Module.GetStorage method")
	}

	if len(mmGetStorage.expectations) > 0 {
		mmGetStorage.mock.t.Fatalf("Some expectations are already set for the Module.GetStorage method")
	}

	mmGetStorage.mock.funcGetStorage = f
	mmGetStorage.mock.funcGetStorageOrigin = minimock.CallerInfo(1)
	return mmGetStorage.mock
}

// Times sets number of times Module.GetStorage should be invoked
func (mmGetStorage *mModuleMockGetStorage) Times(n uint64) *mModuleMockGetStorage {
	if n == 0 {
		mmGetStorage.mock.t.Fatalf("Times of ModuleMock.GetStorage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStorage.expectedInvocations, n)
	mmGetStorage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStorage
}

func (mmGetStorage *mModuleMockGetStorage) invocationsDone() bool {
	if len(mmGetStorage.expectations) == 0 && mmGetStorage.defaultExpectation == nil && mmGetStorage.mock.funcGetStorage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStorage.mock.afterGetStorageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStorage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStorage implements mm_pkg.Module
func (mmGetStorage *ModuleMock) GetStorage() (m1 map[storage.ResourceIndex]storage.StoreObject) {
	mm_atomic.AddUint64(&mmGetStorage.beforeGetStorageCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStorage.afterGetStorageCounter, 1)

	mmGetStorage.t.Helper()

	if mmGetStorage.inspectFuncGetStorage != nil {
		mmGetStorage.inspectFuncGetStorage()
	}

	if mmGetStorage.GetStorageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStorage.GetStorageMock.defaultExpectation.Counter, 1)

		mm_results := mmGetStorage.GetStorageMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStorage.t.Fatal("No results are set for the ModuleMock.GetStorage")
		}
		return (*mm_results).m1
	}
	if mmGetStorage.funcGetStorage != nil {
		return mmGetStorage.funcGetStorage()
	}
	mmGetStorage.t.Fatalf("Unexpected call to ModuleMock.GetStorage.")
	return
}

// GetStorageAfterCounter returns a count of finished ModuleMock.GetStorage invocations
func (mmGetStorage *ModuleMock) GetStorageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStorage.afterGetStorageCounter)
}

// GetStorageBeforeCounter returns a count of ModuleMock.GetStorage invocations
func (mmGetStorage *ModuleMock) GetStorageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStorage.beforeGetStorageCounter)
}

// MinimockGetStorageDone returns true if the count of the GetStorage invocations corresponds
// the number of defined expectations
func (m *ModuleMock) MinimockGetStorageDone() bool {
	if m.GetStorageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStorageMock.invocationsDone()
}

// MinimockGetStorageInspect logs each unmet expectation
func (m *ModuleMock) MinimockGetStorageInspect() {
	for _, e := range m.GetStorageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ModuleMock.GetStorage")
		}
	}

	afterGetStorageCounter := mm_atomic.LoadUint64(&m.afterGetStorageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStorageMock.defaultExpectation != nil && afterGetStorageCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetStorage at\n%s", m.GetStorageMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStorage != nil && afterGetStorageCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetStorage at\n%s", m.funcGetStorageOrigin)
	}

	if !m.GetStorageMock.invocationsDone() && afterGetStorageCounter > 0 {
		m.t.Errorf("Expected %d calls to ModuleMock.GetStorage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStorageMock.expectedInvocations), m.GetStorageMock.expectedInvocationsOrigin, afterGetStorageCounter)
	}
}

type mModuleMockGetWerfFile struct {
	optional           bool
	mock               *ModuleMock
	defaultExpectation *ModuleMockGetWerfFileExpectation
	expectations       []*ModuleMockGetWerfFileExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModuleMockGetWerfFileExpectation specifies expectation struct of the Module.GetWerfFile
type ModuleMockGetWerfFileExpectation struct {
	mock *ModuleMock

	results      *ModuleMockGetWerfFileResults
	returnOrigin string
	Counter      uint64
}

// ModuleMockGetWerfFileResults contains results of the Module.GetWerfFile
type ModuleMockGetWerfFileResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetWerfFile *mModuleMockGetWerfFile) Optional() *mModuleMockGetWerfFile {
	mmGetWerfFile.optional = true
	return mmGetWerfFile
}

// Expect sets up expected params for Module.GetWerfFile
func (mmGetWerfFile *mModuleMockGetWerfFile) Expect() *mModuleMockGetWerfFile {
	if mmGetWerfFile.mock.funcGetWerfFile != nil {
		mmGetWerfFile.mock.t.Fatalf("ModuleMock.GetWerfFile mock is already set by Set")
	}

	if mmGetWerfFile.defaultExpectation == nil {
		mmGetWerfFile.defaultExpectation = &ModuleMockGetWerfFileExpectation{}
	}

	return mmGetWerfFile
}

// Inspect accepts an inspector function that has same arguments as the Module.GetWerfFile
func (mmGetWerfFile *mModuleMockGetWerfFile) Inspect(f func()) *mModuleMockGetWerfFile {
	if mmGetWerfFile.mock.inspectFuncGetWerfFile != nil {
		mmGetWerfFile.mock.t.Fatalf("Inspect function is already set for ModuleMock.GetWerfFile")
	}

	mmGetWerfFile.mock.inspectFuncGetWerfFile = f

	return mmGetWerfFile
}

// Return sets up results that will be returned by Module.GetWerfFile
func (mmGetWerfFile *mModuleMockGetWerfFile) Return(s1 string) *ModuleMock {
	if mmGetWerfFile.mock.funcGetWerfFile != nil {
		mmGetWerfFile.mock.t.Fatalf("ModuleMock.GetWerfFile mock is already set by Set")
	}

	if mmGetWerfFile.defaultExpectation == nil {
		mmGetWerfFile.defaultExpectation = &ModuleMockGetWerfFileExpectation{mock: mmGetWerfFile.mock}
	}
	mmGetWerfFile.defaultExpectation.results = &ModuleMockGetWerfFileResults{s1}
	mmGetWerfFile.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetWerfFile.mock
}

// Set uses given function f to mock the Module.GetWerfFile method
func (mmGetWerfFile *mModuleMockGetWerfFile) Set(f func() (s1 string)) *ModuleMock {
	if mmGetWerfFile.defaultExpectation != nil {
		mmGetWerfFile.mock.t.Fatalf("Default expectation is already set for the Module.GetWerfFile method")
	}

	if len(mmGetWerfFile.expectations) > 0 {
		mmGetWerfFile.mock.t.Fatalf("Some expectations are already set for the Module.GetWerfFile method")
	}

	mmGetWerfFile.mock.funcGetWerfFile = f
	mmGetWerfFile.mock.funcGetWerfFileOrigin = minimock.CallerInfo(1)
	return mmGetWerfFile.mock
}

// Times sets number of times Module.GetWerfFile should be invoked
func (mmGetWerfFile *mModuleMockGetWerfFile) Times(n uint64) *mModuleMockGetWerfFile {
	if n == 0 {
		mmGetWerfFile.mock.t.Fatalf("Times of ModuleMock.GetWerfFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetWerfFile.expectedInvocations, n)
	mmGetWerfFile.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetWerfFile
}

func (mmGetWerfFile *mModuleMockGetWerfFile) invocationsDone() bool {
	if len(mmGetWerfFile.expectations) == 0 && mmGetWerfFile.defaultExpectation == nil && mmGetWerfFile.mock.funcGetWerfFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetWerfFile.mock.afterGetWerfFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetWerfFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetWerfFile implements mm_pkg.Module
func (mmGetWerfFile *ModuleMock) GetWerfFile() (s1 string) {
	mm_atomic.AddUint64(&mmGetWerfFile.beforeGetWerfFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetWerfFile.afterGetWerfFileCounter, 1)

	mmGetWerfFile.t.Helper()

	if mmGetWerfFile.inspectFuncGetWerfFile != nil {
		mmGetWerfFile.inspectFuncGetWerfFile()
	}

	if mmGetWerfFile.GetWerfFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetWerfFile.GetWerfFileMock.defaultExpectation.Counter, 1)

		mm_results := mmGetWerfFile.GetWerfFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetWerfFile.t.Fatal("No results are set for the ModuleMock.GetWerfFile")
		}
		return (*mm_results).s1
	}
	if mmGetWerfFile.funcGetWerfFile != nil {
		return mmGetWerfFile.funcGetWerfFile()
	}
	mmGetWerfFile.t.Fatalf("Unexpected call to ModuleMock.GetWerfFile.")
	return
}

// GetWerfFileAfterCounter returns a count of finished ModuleMock.GetWerfFile invocations
func (mmGetWerfFile *ModuleMock) GetWerfFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWerfFile.afterGetWerfFileCounter)
}

// GetWerfFileBeforeCounter returns a count of ModuleMock.GetWerfFile invocations
func (mmGetWerfFile *ModuleMock) GetWerfFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetWerfFile.beforeGetWerfFileCounter)
}

// MinimockGetWerfFileDone returns true if the count of the GetWerfFile invocations corresponds
// the number of defined expectations
func (m *ModuleMock) MinimockGetWerfFileDone() bool {
	if m.GetWerfFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetWerfFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetWerfFileMock.invocationsDone()
}

// MinimockGetWerfFileInspect logs each unmet expectation
func (m *ModuleMock) MinimockGetWerfFileInspect() {
	for _, e := range m.GetWerfFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ModuleMock.GetWerfFile")
		}
	}

	afterGetWerfFileCounter := mm_atomic.LoadUint64(&m.afterGetWerfFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetWerfFileMock.defaultExpectation != nil && afterGetWerfFileCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetWerfFile at\n%s", m.GetWerfFileMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetWerfFile != nil && afterGetWerfFileCounter < 1 {
		m.t.Errorf("Expected call to ModuleMock.GetWerfFile at\n%s", m.funcGetWerfFileOrigin)
	}

	if !m.GetWerfFileMock.invocationsDone() && afterGetWerfFileCounter > 0 {
		m.t.Errorf("Expected %d calls to ModuleMock.GetWerfFile at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetWerfFileMock.expectedInvocations), m.GetWerfFileMock.expectedInvocationsOrigin, afterGetWerfFileCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ModuleMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetChartInspect()

			m.MinimockGetNameInspect()

			m.MinimockGetNamespaceInspect()

			m.MinimockGetObjectStoreInspect()

			m.MinimockGetPathInspect()

			m.MinimockGetStorageInspect()

			m.MinimockGetWerfFileInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ModuleMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ModuleMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetChartDone() &&
		m.MinimockGetNameDone() &&
		m.MinimockGetNamespaceDone() &&
		m.MinimockGetObjectStoreDone() &&
		m.MinimockGetPathDone() &&
		m.MinimockGetStorageDone() &&
		m.MinimockGetWerfFileDone()
}
